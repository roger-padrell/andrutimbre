<html>
  <head>
    <title>Andrutimbre - Andruino team</title>
  </head>
  <body>
    <button onclick="connect()">Connect</button>
  </body>
  <script>
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
        
   const SerialMonitor = {
  port: null,
  reader: null,
  writer: null,
  keepReading: false,
  buffer: "",

  sentMessages: [],
  receivedMessages: [],

  async connect(baudRate = 9600) {
    if (this.port) return;

    this.port = await navigator.serial.requestPort();
    await this.port.open({ baudRate });

    this.writer = this.port.writable.getWriter();
    this.reader = this.port.readable.getReader();

    this.keepReading = true;
    this.readLoop();
  },

  async disconnect() {
    this.keepReading = false;

    if (this.reader) {
      await this.reader.cancel();
      this.reader.releaseLock();
    }

    if (this.writer) {
      this.writer.releaseLock();
    }

    if (this.port) {
      await this.port.close();
    }

    this.port = null;
  },

  async send(message) {
    if (!this.writer) throw new Error("Not connected");

    const encoder = new TextEncoder();
    await this.writer.write(encoder.encode(message + "\n"));

    this.sentMessages.push({
      message,
      timestamp: new Date()
    });
  },

  async sendAndExpect(message) {
    let beforeLen = this.receivedMessages.length;

    await this.send(message);

    while(this.receivedMessages.length <= beforeLen){
      await sleep(500);
    }

    return this.getLastReceived();
  }

  async readLoop() {
    const decoder = new TextDecoder();

    while (this.keepReading) {
      try {
        const { value, done } = await this.reader.read();
        if (done) break;

        if (value) {
          this.buffer += decoder.decode(value);

          // Process complete lines
          let lines = this.buffer.split("\n");
          this.buffer = lines.pop(); // remaining incomplete part

          for (let line of lines) {
            const clean = line.trim();
            if (clean.length > 0) {
              this.receivedMessages.push({
                message: clean,
                timestamp: new Date()
              });
            }
          }
        }
      } catch (err) {
        break;
      }
    }
  },

  getLastReceived() {
    if (this.receivedMessages.length === 0) return null;
    return this.receivedMessages[this.receivedMessages.length - 1];
  },

  clearHistory() {
    this.sentMessages = [];
    this.receivedMessages = [];
  }
};
  </script>
</html>
